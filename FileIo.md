# 文件IO

## 编译阶段

解决循环import问题

要分析变量->

要能解析泛型->

解析泛型的依据是它的前面是类型->

要知道前面是不是类型需要解析import的文件->先解析import文件

### 解决方案

1. 生成Departed, 先将类型放在文件前面做标识, 类型的信息不做考虑, 因为只有类型会对第3步的编译产生影响(内部类,
   为之奈何qwq)
2. 遍历import表, 对import的文件执行1相关操作
3. 解析文件结构, 解析所有的声明, 再次写入文件
4. 遍历import表, 对import的文件执行3相关操作
5. 逻辑分析, import表中的所有类型都已知结构, 就可以分析本文件中对import的部分结构使用方式是否正确
   本文件解析完毕
6. 遍历import表, 对import表import的文件执行5相关操作

### 阶段一: 类型声明

public callable A(){

}
public callable void A(){

}

- 任务: 本类中的类声明注册完毕
- source.file->SourceString->DepartedPart
- SourceTextContext->DepartedFileBody->binary.file

### 阶段二: 结构解析

- 任务: 解析变量/复合结构/方法的结构后, 即可完成import表的用法
- DepartedFileBody->FileContext->binary.file

### 阶段三: 完成解析

- 任务: 完全完善import表信息
- 检查之前的声明是否正确
- 解析表达式和可执行块, 检查final, const的使用是否正确

## 文件结构设计

### 总体设计

- 阶段二
    - 魔数
    - 完成阶段
    - import表
    - 常量池
    - 已割裂源码信息

- 阶段二
    - 魔数
    - 完成阶段
    - import表
    - 常量池
    - 结构声明
    - 复合类型信息(泛型或元组, 函数签名)
    - 代码块,实现和赋值(已割裂源码信息)

- 阶段三
    - 魔数
    - 完成阶段
    - import表
    - 常量池
    - 结构声明
    - 复合类型信息(泛型或元组, 函数签名)
    - 代码块,实现和赋值(已编译)

都设计协议了, 难道要使用Nio了吗qwq

### 魔数和完成阶段

\[完成阶段\], 2bit? 8bit?

### 常量池

[基本数据类型?]\[常量池表开始标识?\]

- 第一阶段完成: 注册复合结构名, 内部结构名 (函数名(不行吧, 返回值类型涉及泛型)和变量名(不太行, 因为变量涉及泛型))
- 第二阶段完成: 注册类名, 复合结构名, 变量名, 函数名, 将类名后面指向文件中自己的具体声明
- 第三阶段完成: 遍历常量池, 以此遍历它们的声明, 检查它们的声明正确与否

  包括文件级别的函数变量和复合类型, 也包括类内嵌套的各种数据信息

    - 共计 (24Bit+)
    - 字符串长度(12bit)
    - 指向声明结构(12bit)
    - 名字字符串(字节数组)

- [import表] 其实是常量池的一部分, 但是和常量池的元素的区别在于无法指向内部的文件

    - 共计 (24Bit+)
    - 字符串长度(12bit)
    - 指向声明结构(12bit), 全空
    - 名字字符串(字节数组)

### 结构声明

在第二阶段完成,

如果是复合类型, 就指向复合类型, 基本数据类型, 设计特定的编码, 设计一位表示数组类型

\[结构声明表开始标识\]

- 共计 共56Bit
- 访问控制(8bit)
- 类型id, 指向类型具体信息, (12Bit)
- 变量名id, 指向常量池, (16bit)
- 代码块实现/赋值ID, (16Bit)\

### 复合类型信息

泛型或元组, 函数签名 ,基本数据类型, 设计特定的编码, 设计一位表示数组类型, (函数内函数...)也需要...

\[复合类型信息表开始标识\]

- 共计 16Bit+
- 常量ID数量(12Bit)
- 是泛型/元组/函数签名(4bit)
- 常量池id列表或基本数据类型(16Bit)

### 代码块

> 实现和赋值

- 一个代码块的长度字节数\[24Bit\]
- 很长,指令( TODO )
- 一个代码块中的源码表的长度
- 每一个表达式在源码中的行信息要保留, 用于异常栈的输出

## 基本数据类型

1. import的类型

| 类型             | 编码          |
|----------------|-------------|
| import的类型      | 0xffffff    |
| bool           | 0xffffff-1  |
| char           | 0xffffff- 2 |
| float32        | 0xffffff- 3 |
| float64        | 0xffffff- 4 |
| int8           | 0xffffff-5  |
| int16          | 0xffffff-6  |
| int32          | 0xffffff- 7 |
| int64          | 0xffffff-8  |
| unsigned int8  | 0xffffff-9  |
| unsigned int16 | 0xffffff-10 |
| unsigned int32 | 0xffffff-11 |
| unsigned int64 | 0xffffff-12 |
| var            | 0xffffff-13 |
| 未确定类型          | 0xffffff-14 |

## var 类型

在解析代码编译的最终阶段, var类型将变为最终的合适的类型

如果是某个方法的返回值, 应当将方法的返回值导入(import), 放入import表中

## 依赖影响

一个文件发生改变, 实现的改变不论, 但是方法/函数签名改变, 字段签名改变或类签名改变

都将导致这个类对引用它的对象造成改变, 要重新检查其他类型对它的引用是否正确

编译项目/多文件时, 总是在根目录创建一个依赖互相引用表(邻接矩阵表(吗?))

也在开头构造常量表, 然后获取常量表指向索引, 索引和索引构成二维矩阵, 0表示不引用, 1表示引用

1Byte可以存8个, 真不错

## 文件变化

发生实质性变化的时候进行编译(好难啊)

我看Java, 改了空格或注释, 是会变的, 也会进行依赖分析

那咋办呢... 文件比对吗? 源码和字节码怎么比对? 阿西吧

本文件先进行一波编译, 然后编译了的和已经存在的比对吗? 比对不通过覆盖原字节码, 然后进行依赖分析吗? 🤔

### 文件比对

注意到, 字节码文件的各种表, 它们是无序的, 比对的时候不能简单比较它们是否是相同的吧?

可以重写Hash和Equals吧, 然后用Set, 这样形成的Set表应该是相同的

代码块的话直接仔细比对(可能嵌套常量池比对)

常量池比对:

- 常量池->结构声明
- 结构声明的方法->复合类型声明
- 代泛型的类型->复合类型声明
- 变量也可能指向复合类型声明, 可能是代泛型的类做类型
- 函数不能直接做类型, 而是用函数类callable<AAA,BBB>这样
- 比对常量池的时候, 只比对常量名
- 然后指向结构, 比对结构
- 结构指向复合类型或常量池
- 结构如果指向常量池, 再次比对常量池的名字, 然后结束
- 如果指向复合结构, 比对复合结构, 复合结构会指向常量池, 比对常量池然后结束

一言以蔽之:

- 遍历常量池表, 递归嵌套比对, 以第二次比对常量池的数据为递归出口

## 难点

- 文件内如何指向? 答: 每个部分建造一个表, 使用表内的索引
- 源码分割设计? (48Bit+)
    - raw (14bit)
    - col (14bit)
    - TYPE (8Bit)
    - 字符串长 (12Bit)
    - 字符串 (不定长)

## 改进

其实第一阶段, 可以将声明检查, 解析了, 只有变量的identifier和expression无法被解析

函数和Block也可以完成对应

问题在于, 如何对应? 直接Add, 然后记录吗?
问题在于, 怎么保证不会被更改? 超级慌

## package 与 import

编译时的编译命令, 例如 via-c 命令

```shell
via-c filename properties-file=../../../resource/property.properties max-size=1024GB
```

```shell
vai-c package-name base-package=src/via/main
```

src/via/main下有org/hb/via/File.via, 那么, File.via的package就是org.hb.via
否则, 如果省略这个参数, 默认package就是 src.via.main.org.hb.via
如果是file, 那么默认package就是没有


