/**
 * 拿到一个文件
 * 1. 将当前文件全部加载到内存, 转为链表
 * <p>
 * 2. 从链表中读所在包
 * <p>
 * 引用处理
 * 引用是从底部文件夹开始到文件名的路径, 读到一个是文件名
 * 如果最后不是文件名, 文件名在最后出现, 之后的可能是成员(类/类.类的静态成员);
 * 依次读, 先依据名字找文件夹, 找不到文件夹, 加上后缀.hb, 然后找文件, 找不到文件报错
 * 找到了文件, 如果还有东西, 那就是文件的成员了
 * <p>
 * 引用
 * 3. 从链表中读取引入的文件
 * 4. 将引入的文件注册到当前文件的引入文件列表中
 * 5. 当前文件处理成声明文件(合成一些列表的元素, 成为类签名/方法签名/字段签名等)
 * 6. 解析引入文件列表
 * 7. 尝试获取该引入文件的声明文件
 * 8. 有声明文件的文件跳过
 * 9. 无声明文件的文件获取源码文件, 解析该源码文件(回到1)
 * * 由于先将本文件处理成声明文件, 声明文件不需要链接, 也不需要获取任何其他文件的信息,所以解决了循环依赖
 * 10. 获取到解析文件后, 解析引入文件后面的元素, 将元素存入列表
 * <p>
 * 引入
 * 是否设计成"只在文件开头引入头文件", C#, Java都是这种策略, 逻辑也会方便很多
 * 1. 对于要编译的文件, 先获取其import, 然后将其注册到表中, 释放该文件
 * 2. 遍历import的文件列表, 如果还没有编译, 先获取这个文件的import
 * 3. 重复此过程, 直到遇到没有导入任何包的文件
 * 4. 如果遇到了循环导入的问题...
 * 5. 由于A导入B, B导入C, A不算导入C, 如果A要导入C必须在文件A内importC, 也不会出现长长的环构成的循环依赖了
 * 6. 如果遇到直接的A->B, B->A, 先编译没有循环在一起的文件
 * 7. A->B, B->A, A->C, C->A, A->D,D->A, B->D,D->A
 * <p>
 * 11. 将当前的声明文件转为中间代码文件
 * 12. 将所有的引入文件的声明文件转为中间代码文件
 * <p>
 * <p>
 * 转为中间代码文件:
 * 1. 检查循环继承
 * 2. 不支持字符串相加, 后期如果能自己实现一个库的话, 就给出StringBuilder好了
 * 3. 支持重载运算符
 * 4. 不支持友元
 * 5. 支持全局的函数吗, 不支持, 全局的方法总能以其他形式实现, 不是必须的
 * <p>
 * 访问限制
 * 1 private 本类及其内部类
 * 2 protected private+其子类
 * 4 public 所有的
 * 8 file 本文件
 * 16 package 本包及其子包
 * 1 default private
 * 多个作用域可以合成(|)
 * <p>
 * native 关键字, 能够连接CPP库?
 * <p>
 * 中间码解释器
 * 中间码编译器
 * 用CPP写
 * <p>
 * <p>
 * GC 垃圾回收器
 * ? 开启中间码解释器的时候就已经开启GC伴随线程
 * 中间码编译器编译之后, 那GC怎么办?
 * GC垃圾回收器要用cpp写吗? ...也行
 * <p>
 * <p>
 * import, 作为在编译期作为包名的简写工具, 在编译使其马上为其添加上前缀?
 * 那么几个加载阶段就要重新考虑...如果涉及泛型, 要尝试读文件, 判断是文件, 是包
 * 如果文件流不关闭,
 * 还是作为一个
 */
package org.harvey.compiler;
// 需求分析:
// 1. 文件级变量的必要性:
//      优点:
//          全局可见
//          调用方便
//      缺点:
//          加载之后永远不可能被回收
//          文件级变量由于没有上下文, 其使用变得意义不明
//
// 2. 重载运算符采用operator关键字(c++), 还是重载接口
//      重载接口: 更规范, 更好编译, 对于一些运算符, 不限定参数个数的, 例如函数调用运算符
//      operator关键字: 引入新的关键字, 编译要重新解析
//
//  3. 多返回值
//      在需求上:
//      可以避免因为函数有多个出口而要定义一个类封装多个结果的情况
//      但是, 多返回值的函数, 对外暴露的函数签名中的返回值, 只有返回值类型, 没有返回值的意义, 使可读性降低
//      在实现上:
//      要实现Tuple和, 就需要实现不定个数的泛型列表(见4)
//      要不就是所有的类型的父类Object作为泛型, 这样, Java也可以是实现多返回值了! return List.of(new Object(),Integer.valueOf(12));
//      没有意义!
//      要不就是将返回值实现成, 类型字节码(涉及反射): 返回值这样两个封装起来, 再装入Tuple<Pair<Class<T>,T>>的形式
//
// 4. 不定个数的泛型
//      class Tuple<T...>{
//          T[0] t0;
//          T[1] t1;
//          {
//              if(T==null||T.length==0){
//                  throw new "泛型参数列表不可为null!";
//              }
//          }
//      }
//      不可理喻!
//
// 5. 在方法中声明类/函数
//      这个类什么时候加载? 如果在循环的结构里, 要不要反复加载? 加载完之后, 重新调用函数, 要不要再次加载?
//
// 6. lambda表达式
//      苦Java传入lambda表达式里的变量只能final久矣!
//      但是, 支持变量在lambda里面改变, 就好了吗? 如果一个lambda表达式作为返回值离开了函数的范围, 但是这个lambda表达式里又包含了本函数里的局部变量, 怎么办?
//      Java将其设置为final, 正是因为其是值传递, 值传递的变量对外界不会产生影响, 在编译期间就报错, 是为了引起程序员的注意, 避免不必要的错误!
//      Java应该是解析了lambda表达式中引入的外部的变量的值, 然后做类似与将这些值传入编译器生成的构造函数
//      然后构造函数内将值赋给编译器自动生成的匿名内部类的final字段
//      那么, 这个编译器应该怎么做呢?
