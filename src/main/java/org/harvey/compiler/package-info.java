// 拿到一个文件
// 1. 将当前文件全部加载到内存, 转为链表

// 2. 从链表中读所在包

// 引用处理
// 引用是从底部文件夹开始到文件名的路径, 读到一个是文件名
// 如果最后不是文件名, 文件名在最后出现, 之后的可能是成员(类/类.类的静态成员);
// 依次读, 先依据名字找文件夹, 找不到文件夹, 加上后缀.hb, 然后找文件, 找不到文件报错
// 找到了文件, 如果还有东西, 那就是文件的成员了

// 引用
// 3. 从链表中读取引入的文件
// 4. 将引入的文件注册到当前文件的引入文件列表中
// 5. 当前文件处理成声明文件(合成一些列表的元素, 成为类签名/方法签名/字段签名等)
// 6. 解析引入文件列表
// 7. 尝试获取该引入文件的声明文件
// 8. 有声明文件的文件跳过
// 9. 无声明文件的文件获取源码文件, 解析该源码文件(回到1)
// * 由于先将本文件处理成声明文件, 声明文件不需要链接, 也不需要获取任何其他文件的信息,所以解决了循环依赖
// 10. 获取到解析文件后, 解析引入文件后面的元素, 将元素存入列表

// 11. 将当前的声明文件转为中间代码文件
// 12. 将所有的引入文件的声明文件转为中间代码文件


// 转为中间代码文件:
// 1. 检查循环继承
// 2. 不支持字符串相加, 后期如果能自己实现一个库的话, 就给出StringBuilder好了
// 3. 支持重载运算符
// 4. 不支持友元
// 5. 支持全局的函数吗, 不支持, 全局的方法总能以其他形式实现, 不是必须的

// 访问限制
// 1 private 本类及其内部类
// 2 protected private+其子类
// 4 public 所有的
// 8 file 本文件
// 16 package 本包及其子包
// 1 default private
// 多个作用域可以合成(|)

// native 关键字, 能够连接CPP库

// 中间码解释器
// 中间码编译器
// 用CPP写
//

// GC 垃圾回收器
// ? 开启中间码解释器的时候就已经开启GC伴随线程
// 中间码编译器编译之后, 那GC怎么办?
// GC垃圾回收器要用cpp写吗? ...也行
package org.harvey.compiler;
